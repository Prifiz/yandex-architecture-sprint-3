# Задание 1.1

## Функциональность монолита

### Управление отоплением:

* Пользователи могут удалённо включать/выключать отопление в своих домах.
* Пользователи могут устанавливать желаемую температуру.
* Система автоматически поддерживает заданную температуру, регулируя подачу тепла.

### Мониторинг температуры:

* Система получает данные о температуре с датчиков, установленных в домах.
* Пользователи могут просматривать текущую температуру в своих домах через веб-интерфейс.

### Архитектура монолитного приложения:

Собственно в тексте задания уже приведен анализ архитектуры монолита,
оставлю здесь именно его.

* Язык программирования: Java
* База данных: PostgreSQL
* Архитектура: Монолитная, все компоненты системы (обработка запросов, бизнес-логика, работа с данными) находятся в рамках одного приложения.
* Взаимодействие: Синхронное, запросы обрабатываются последовательно.
* Масштабируемость: Ограничена, так как монолит сложно масштабировать по частям.
* Развертывание: Требует остановки всего приложения.

## Доменная модель

Приведена на диаграмме DomainsContexts.puml

# Задание 1.2

Схемы приведены в файлах Task1.2_C2.puml и Task1.2_C3.puml

В С4 на уровне классов особого смысла здесь не вижу, 
т.к. уже на уровне компонентов де-факто оперируем java-классами

# Задание 1.3

ER-диаграмма приведена одна для всей системы, а не отдельная для каждого сервиса
с целью отражения полной картины.


# Задание 1.4

Описание API приведено в файлах api.yaml, расположенных в корне директорий сервисов 
device-manager-service и telemetry-manager-service
для сервисов управления устройствами и телеметрии, соответственно.

В реальном приложении конечно же управление пользователями я бы вынес
в отдельный сервис, но здесь слишком накладно по времени.
Причем скорее всего и работа с инфраструктурой поселков (сущности а-ля "поселок", "дом" и скорее всего "помещение")
в реальности была бы вынесена в отдельный сервис или группу сервисов.
Поэтому в рамках этой учебной работы принято решение оставить пользователей в рамках device-manager-service.
Здесь делаем предположение, что в веб-интерфейсе доступно id устройства пользователя,
по которому будем получать телеметрию из сервиса telemetry-manager-service.
Опять-таки ввиду дефицита времени ограничимся частными задачами просмотра телеметрии
заданного устройства, без, например, выборки устройств по домам, типам и пр. - 
считаем, что это утвержденные ограничения MVP. 


В реальном проекте это всё естественно
требует коммуникации с заказчиком и выяснения всех подробностей и выстраивания приоритетов
исходя из потребностей бизнеса (это из разряда "вы не подумайте, я умею правильно,
но в текущих условиях делаю по-быстрому, иначе есть риск ничего не успеть")

# Задания 2.1-2.2

Микросервисы реализованы в директориях device-manager-service и telemetry-manager-service
Монолит при этом отмирает (в репозитории остался, не мешает)

## Запуск

выполнить в корне 

```bash
docker compose up
```

## Как проверить
По запросам реализован только happy path,
в исключительных ситуациях везде код 500, 
поэтому просто идем по коридору в соответствии с инструкцией ниже
### Добавить пользователя (эмулируем регистрацию)
POST http://localhost:9090/device-mgr/api/user
За одно этот и последующие запросы проверят API Gateway, 
т.к. вызываем прокси-путь device-mgr и telemetry-mgr вместо конкретных сервисов
Формат RequestBody описан в device-manager-service/api.yaml,
например,
```json
{
    "name": "Вася Пупкин Мамкин Автоматизатор"
}
```
Запоминаем id из ответа (был бы фронт, он бы запомнил)

### Добавляем поддержку нового типа устройства
POST http://localhost:9090/device-mgr/api/device-type
RequestBody:
```json
{
    "name": "Страшно умный тандыр"
}
```
Запоминаем id из ответа (был бы фронт, он бы запомнил)

### Добавляем данные о доме, где будет располагаться устройство
POST http://localhost:9090/device-mgr/api/house
```json
{
  "address": "Поселок Кривые Костыли, пл. им. Упавшего Прода, д.13",
  "userId": // сюда вписываем id пользователя из ответа от /device-mgr/api/user
}
```
Запоминаем id из ответа (был бы фронт, он бы запомнил)

### Добавляем данные о новом устройстве
POST http://localhost:9090/device-mgr/api/device
```json
{
    "name": "Адский тандыр от компании 8 дыр",
    "houseId": , // сюда вписываем id дома из ответа от /device-mgr/api/house
    "deviceTypeId": , // сюда вписываем id типа устройства из ответа от /device-mgr/api/device-type
    "serial": "aaaa-bbbb-cccc-dddd",
    "status": "ON" // допустим, добавляем сразу включенным
}
```
Запоминаем id из ответа (был бы фронт, он бы запомнил)

### Отправляем команду на устройство

В обоих запросах ниже в pathVariable вместо {device_id} 
подставляем id из ответа от /device-mgr/api/device

POST http://localhost:9090/device-mgr/api/device/{device_id}/command
```json
{
    "commandText": "Зажигай!"
}
```
Открываем kafka-ui на localhost:7777 и проверяем, что в топике commands появилось сообщение с командой

### Меняем статус устройства
PUT http://localhost:9090/device-mgr/api/device/{device_id}/status
```json
{
    "status": "OFF"
}
```
Открываем kafka-ui на localhost:7777 и проверяем, что в топике statuses появилось сообщение с новым статусом
Можно также подключиться к БД и проверить, что в таблице device также поле status поменялось -
в данном задании это происходит вместе с отправкой сообщения для наглядности

### Эмулируем получение телеметрии
Открываем kafka-ui, создаем топик sensor_data, если его нет.
Добавляем в топик сообщение:
```json
{
	"deviceId": , // id из ответа от /device-mgr/api/device
	"producedAt": "2024-10-02T00:45:00", // в принципе любая дата и время, в которое устройство "сгенерировало" телеметрию
	"telemetryUnit": "temperature", // любая строка, это тип передаваемых показаний (измеряемая физическая величина) 
	"data": "100500 C" // значение показаний телеметрии
}
```
Можно повторить несколько раз, но в принципе для проверки хватит и одного

### Получаем показания телеметрии
В обоих запросах ниже в pathVariable вместо {device_id}
подставляем id из ответа от /device-mgr/api/device

#### Самые свежие показания по заданному устройству
GET http://localhost:9090/telemetry-mgr/api/device/{device_id}/telemetry/latest

#### Показания за период
POST http://localhost:9090/telemetry-mgr/api/device/{device_id}/telemetry
```json
{
    "from": "2024-01-01T00:00:00",
    "to": "2024-12-31T23:59:59"
}
```

# Задание 3

Не выполнено, ибо жук-невывожук закопался в дедлайны по работе. А тем временем уже подходила к концу 1-я неделя следующего спринта...